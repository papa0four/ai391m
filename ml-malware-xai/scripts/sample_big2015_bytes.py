"""
scripts/sample_big2015_bytes.py

Randomly sample up to N .bytes files from BIG2015 train.7z and extract them
into a target directory (e.g. data/big2015/bytes).

Usage (from project root):

  python .\\scripts\\sample_big2015_bytes.py `
    --train_7z .\\data\\big2015\\train.7z `
    --labels_csv .\\data\\big2015\\trainLabels.csv `
    --out_dir .\data\\big2015\\bytes `
    --num_samples 5000 `
    --seed 42

Requirements:
  pip install py7zr pandas
"""

import argparse
import os
import random
from typing import Dict, List, Set

import pandas as pd
import py7zr


def load_labels(labels_csv: str) -> List[str]:
    """Load Id column from trainLabels.csv as a list of sample IDs."""
    df = pd.read_csv(labels_csv)
    if "Id" not in df.columns:
        raise ValueError("Expected trainLabels.csv to have an 'Id' column.")
    return df["Id"].astype(str).tolist()


def index_bytes_files(train_7z: str) -> Dict[str, str]:
    """
    Build a map from sample_id -> archive member name for all .bytes files
    in the 7z archive.
    """
    id_to_member: Dict[str, str] = {}

    with py7zr.SevenZipFile(train_7z, mode="r") as archive:
        names = archive.getnames()
        for name in names:
            if not name.lower().endswith(".bytes"):
                continue
            base = os.path.basename(name)
            sample_id, _ext = os.path.splitext(base)
            id_to_member[sample_id] = name

    if not id_to_member:
        raise RuntimeError(
            f"No .bytes files found in archive {train_7z}. "
            "Check that you downloaded the correct train.7z."
        )

    print(f"[sample_big2015] Indexed {len(id_to_member)} .bytes entries from archive.")
    return id_to_member


def sample_ids(
    all_ids: List[str],
    available_ids: Set[str],
    num_samples: int,
    seed: int,
) -> List[str]:
    """
    Randomly sample up to num_samples IDs that are actually present
    in the archive (.bytes files).
    """
    # Keep only IDs that we know have .bytes in the archive
    valid_ids = [i for i in all_ids if i in available_ids]

    if not valid_ids:
        raise RuntimeError(
            "No IDs in trainLabels.csv have matching .bytes files in the archive."
        )

    if num_samples > len(valid_ids):
        print(
            f"[sample_big2015] Requested {num_samples} samples, "
            f"but only {len(valid_ids)} available. Using {len(valid_ids)}."
        )
        num_samples = len(valid_ids)

    random.seed(seed)
    sampled = random.sample(valid_ids, num_samples)
    print(f"[sample_big2015] Selected {len(sampled)} sample IDs.")
    return sampled


def extract_selected_bytes(
    train_7z: str,
    id_to_member: Dict[str, str],
    sampled_ids: List[str],
    out_dir: str,
) -> None:
    """Extract only the selected .bytes members from the archive into out_dir."""
    os.makedirs(out_dir, exist_ok=True)

    # Compute member names to extract
    targets = [id_to_member[sid] for sid in sampled_ids]

    print(f"[sample_big2015] Extracting {len(targets)} .bytes files to {out_dir} ...")
    with py7zr.SevenZipFile(train_7z, mode="r") as archive:
        archive.extract(path=out_dir, targets=targets)

    # After extraction, many 7z archives keep their internal folder structure.
    # Optionally, normalize by moving any nested .bytes to the root of out_dir.
    for root, _dirs, files in os.walk(out_dir):
        for name in files:
            if not name.lower().endswith(".bytes"):
                continue
            full_path = os.path.join(root, name)
            dest_path = os.path.join(out_dir, name)
            if os.path.abspath(full_path) != os.path.abspath(dest_path):
                if not os.path.exists(dest_path):
                    os.replace(full_path, dest_path)

    print("[sample_big2015] Extraction complete.")


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Sample and extract a subset of BIG2015 .bytes files from train.7z."
    )
    parser.add_argument(
        "--train_7z",
        required=True,
        help="Path to BIG2015 train.7z",
    )
    parser.add_argument(
        "--labels_csv",
        required=True,
        help="Path to trainLabels.csv",
    )
    parser.add_argument(
        "--out_dir",
        required=True,
        help="Output directory for extracted .bytes files (e.g. data/big2015/bytes)",
    )
    parser.add_argument(
        "--num_samples",
        type=int,
        default=5000,
        help="Number of samples to extract (default: 5000).",
    )
    parser.add_argument(
        "--seed",
        type=int,
        default=42,
        help="Random seed for reproducible sampling.",
    )
    return parser.parse_args()


def main() -> None:
    args = parse_args()

    if not os.path.exists(args.train_7z):
        raise FileNotFoundError(f"train_7z not found: {args.train_7z}")
    if not os.path.exists(args.labels_csv):
        raise FileNotFoundError(f"labels_csv not found: {args.labels_csv}")

    all_ids = load_labels(args.labels_csv)
    id_to_member = index_bytes_files(args.train_7z)
    sampled_ids = sample_ids(
        all_ids,
        available_ids=set(id_to_member.keys()),
        num_samples=args.num_samples,
        seed=args.seed,
    )
    extract_selected_bytes(args.train_7z, id_to_member, sampled_ids, args.out_dir)

    print(
        f"[sample_big2015] Done. You can now run your big2015_extractor "
        f"on {args.out_dir}."
    )


if __name__ == "__main__":
    main()
