# scripts/make_ember_features.py
from __future__ import annotations
import os, argparse, numpy as np

def main():
    ap = argparse.ArgumentParser(description="Use official EMBER API to vectorize and emit features.npz")
    ap.add_argument("--ember_dir", required=True,
                    help="Directory that contains train_features_*.jsonl and test_features.jsonl (EMBER 2018)")
    ap.add_argument("--out_npz", required=True,
                    help="Output path for canonical NPZ (e.g., data/ember/ember2018/processed/features.npz)")
    ap.add_argument("--force_revectorize", action="store_true",
                    help="Force re-run of ember.create_vectorized_features even if X_*.dat already exist")
    args = ap.parse_args()

    import ember  # installed from GitHub

    # 1) Vectorize raw features to X_train.dat / y_train.dat / X_test.dat / y_test.dat if needed
    need_vec = args.force_revectorize
    for fname in ("X_train.dat", "y_train.dat", "X_test.dat", "y_test.dat"):
        if not os.path.exists(os.path.join(args.ember_dir, fname)):
            need_vec = True
    if need_vec:
        print("[INFO] Running ember.create_vectorized_features(...) — this can take a while.")
        ember.create_vectorized_features(args.ember_dir)  # writes .dat files in place

    # 2) Load vectorized arrays
    print("[INFO] Reading vectorized features with ember.read_vectorized_features(...)")
    X_train, y_train, X_test, y_test = ember.read_vectorized_features(args.ember_dir)

    # 3) Merge train+test (we’ll re-split later in src.preprocess for reproducibility)
    X = np.vstack([np.asarray(X_train), np.asarray(X_test)]).astype(np.float32, copy=False)
    y = np.concatenate([np.asarray(y_train).astype(np.int64),
                        np.asarray(y_test).astype(np.int64)])

    # 4) Feature names are not published; use stable placeholders
    ndim = X.shape[1]
    feat_names = np.array([f"ember_f{i}" for i in range(ndim)], dtype=object)
    class_names = np.array(["benign", "malicious"], dtype=object)

    # 5) Save canonical NPZ for our pipeline
    os.makedirs(os.path.dirname(args.out_npz), exist_ok=True)
    np.savez_compressed(args.out_npz, X=X, y=y, feat_names=feat_names, class_names=class_names)
    print(f"[OK] Wrote {args.out_npz} with X={X.shape}, y={y.shape}")

if __name__ == "__main__":
    main()
